{"basic concepts": "This section provides definitions for the specific terminology and the concepts used when describing the C++ programming language.\n", "programming": "The first programmer was a girl named ADA Lovelace.She described an algorithm for the Analytical Engine to compute Bernoulli numbers. Since the algorithm was considered to be the first specifically written for implementation on a computer, she has been cited as the first computer programmer.", "comment": "Comments serve as a sort of in-code documentation. When inserted into a program, they are effectively ignored by the compiler; they are solely intended to be used as notes by the humans that read source code. Although specific documentation is not part of the C++ standard, several utilities exist that parse comments with different documentation formats.\n", "ascii chart": "The following chart contains all 128 ASCII decimal (dec), octal (oct), hexadecimal (hex) and character (ch) codes.\n", "names and identifiers": "An identifier is an arbitrarily long sequence of digits, underscores, lowercase and uppercase Latin letters, and most Unicode characters (see below for details). A valid identifier must begin with a non-digit character (Latin letter, underscore, or Unicode non-digit character). Identifiers are case-sensitive (lowercase and uppercase letters are distinct), and every character is significant.\n", "types": "Objects, references, functions including function template specializations, and expressions have a property called type, which both restricts the operations that are permitted for those entities and provides semantic meaning to the otherwise generic sequences of bits.\n", "fundamental types": "(See also type for type system overview and  the list of type-related utilities that are provided by the C++ library)\n", "object": "C++ programs create, destroy, refer to, access, and manipulate objects.\n", "scope": "Each name that appears in a C++ program is only valid in some possibly discontiguous\nportion of the source code called its scope.\n", "lifetime": "Every object and reference has a lifetime, which is a runtime property: for any object or reference, there is a point of execution of a program when its lifetime begins, and there is a moment when it ends.\n", "definitions and odr": "Definitions are declarations that fully define the entity introduced by the declaration. Every declaration is a definition, except for the following:\n", "name lookup": "Name lookup is the procedure by which a name, when encountered in a program, is associated with the declaration that introduced it.\n", "qualified": "A qualified name is a name that appears on the right hand side of the scope resolution operator :: (see also qualified identifiers).\nA qualified name may refer to a \n", "unqualified": "For an unqualified name, that is a name that does not appear to the right of a scope resolution operator ::, name lookup examines the scopes as described below, until it finds at least one declaration of any kind, at which time the lookup stops and no further scopes are examined. (Note: lookup from some contexts skips some declarations, for example, lookup of the name used to the left of :: ignores function, variable, and enumerator declarations, lookup of a name used as a base class specifier ignores all non-type declarations)\n", "as-if rule": "Allows any and all code transformations that do not change the observable behavior of the program\n", "undefined behavior": "Renders the entire program meaningless if certain rules of the language are violated.\n", "memory model and data races": "Defines the semantics of computer memory storage for the purpose of the C++ abstract machine.\n", "phases of translation": "The C++ source file is processed by the compiler as if the following phases take place, in this exact order:\n", "the main() function": "A program shall contain a global function named main, which is the designated start of the program. It shall have one of the following forms:\n", "modules": "Modules help divide large amounts of code into logical parts.\n", "c++ keywords": "This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading. \n", "preprocessor": "The preprocessor is executed at translation phase 4, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.\n", "#if - #ifdef - #else - #endif": "The preprocessor supports conditional compilation of parts of source file. This behavior is controlled by #if, #else, #elif, #ifdef, #ifndef and #endif directives.\n", "#define - # - ##": "The preprocessor supports text macro replacement. Function-like text macro replacement is also supported.\n", "#include": "Includes other source file into current source file at the line immediately after the directive.\n", "#error": "Shows the given error message and renders the program ill-formed.\n", "#pragma": "Implementation defined behavior is controlled by #pragma directive.\n", "#line": "Changes the current file name and number in the preprocessor.\n", "expressions": "An expression is a sequence of operators and their operands, that specifies a computation.\n", "value categories": "Each C++ expression (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: a type and a value category. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories: prvalue, xvalue, and lvalue.\n", "evaluation order and sequencing": "Order of evaluation of any part of any expression, including order of evaluation of function arguments is unspecified (with some exceptions listed below). The compiler can evaluate operands and other subexpressions in any order, and may choose another order when the same expression is evaluated again.\n", "constant expressions": "Defines an expression that can be evaluated at compile time.\n", "operators": "An expression is a sequence of operators and their operands, that specifies a computation.\n", "assignment": "Assignment operators modify the value of the object. \n", "arithmetic": "Returns the result of specific arithmetic operation.\n", "increment and decrement": "Increment/decrement operators increment or decrement the value of the object. \n", "logical": "Returns the result of a boolean operation.\n", "comparison": "Compares the arguments.\n", "member access and indirection": "Accesses a member of its operand.\n", "call, comma, ternary": "The function call operator provides function semantics for any object.\n", "sizeof": "Queries size of the object or type.\n", "alignof": "Queries alignment requirements of a type\n", "new": "Creates and initializes objects with dynamic storage duration, that is, objects whose lifetime is not limited by the scope in which they were created.\n", "delete": "Destroys object(s) previously allocated by the  new expression and releases obtained memory area\n", "typeid": "Queries information of a type.\n", "operator overloading": "Customizes the C++ operators for operands of user-defined types.\n", "default comparisons": "Provides a way to request the compiler to generate consistent relational operators for a class.\n", "operator precedence": "The following table lists the precedence and associativity of C++ operators. Operators are listed top to bottom, in descending precedence. \n", "conversions": "An expression is a sequence of operators and their operands, that specifies a computation.\n", "implicit": "Implicit conversions are performed whenever an expression of some type T1 is used in context that does not accept that type, but accepts some other type T2; in particular:\n", "explicit": "Converts between types using a combination of explicit and implicit conversions.\n", "user-defined": "Allows integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix.\n", "static_cast": "Converts between types using a combination of implicit and user-defined conversions.\n", "dynamic_cast": "Safely converts pointers and references to classes up, down, and sideways along the inheritance hierarchy.\n", "const_cast": "Converts between types with different cv-qualification.\n", "reinterpret_cast": "Converts between types by reinterpreting the underlying bit pattern.\n", "literals": "An expression is a sequence of operators and their operands, that specifies a computation.\n", "boolean": "The Boolean literals are the keywords true and false. They are prvalues of type bool.\n", "integer": "Allows values of integer type to be used in expressions directly.\n", "floating": "Floating point literal defines a compile-time constant whose value is specified in the source file.\n", "character": "a character from the source character set minus single-quote ('), backslash (\\), or the newline character\n", "string": "\n", "nullptr": "The keyword nullptr denotes the pointer literal. It is a prvalue of type std::nullptr_t. There exist implicit conversions from nullptr to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type std::nullptr_t as well as the macro NULL.\n", "declaration": "Declarations introduce (or re-introduce) names into the C++ program. Each kind of entity is declared differently. Definitions are declarations that are sufficient to use the entity identified by the name. \n", "namespace declaration": "Namespaces provide a method for preventing name conflicts in large projects.\n", "namespace alias": "Namespace aliases allow the programmer to define an alternate name for a namespace.  \n", "lvalue and rvalue references": "Declares a named variable as a reference, that is, an alias to an already-existing object or function.\n", "pointers": "Declares a variable of a pointer or pointer-to-member type.\n", "arrays": "Declares an object of array type.\n", "structured bindings": "Binds the specified names to subobjects or elements of the initializer.\n", "enumerations and enumerators": "An enumeration is a distinct type whose value is restricted to a range of values (see below for details), which may include several explicitly named constants (\"enumerators\"). The values of the constants are values of an integral type known as the underlying type of the enumeration.\n", "storage duration and linkage": "The storage class specifiers are a part of the decl-specifier-seq of a name's declaration syntax. Together with the scope of the name, they control two independent properties of the name: its storage duration and its linkage. \n", "language linkage": "Provides for linkage between modules written in different programming languages.\n", "inline specifier": "The inline specifier, when used in a function's decl-specifier-seq, declares the function to be an inline function.\n", "inline assembly": "asm-declaration gives the ability to embed assembly language source code within a C++ program. This declaration is conditionally-supported and implementation defined, \nmeaning that it may not be present and, even when provided by the implementation, it does not have a fixed meaning.\n", "const/volatile": "Appear in any type specifier, including decl-specifier-seq of  declaration grammar, to specify constness or volatility of the object being declared or of the type being named.\n", "constexpr": "The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time constant expressions are allowed (provided that appropriate function arguments are given). A constexpr specifier used in an object declaration  or non-static member function (until C++14) implies const. A constexpr specifier used in a function  or static member variable (since C++17) declaration implies inline. If any declaration of a function or function template has a constexpr specifier, then every declaration must contain that specifier.\n", "consteval": "The consteval specifier declares a function or function template to be an immediate function, that is, every potentially evaluated call (i.e. call out of an unevaluated context) to the function must (directly or indirectly) produce a compile time constant expression. It may not be applied to destructors, allocation functions, or deallocation functions. A consteval specifier implies inline. At most one of the constexpr, consteval, and constinit specifiers is allowed to appear within the same sequence of declaration specifiers. If any declaration of a function or function template contains a consteval specifier, then all declarations of that function or function template must contain that specifier.\n", "constinit": "The constinit specifier declares a variable with static or thread storage duration. If a variable is declared with constinit, its initializing declaration must be applied with constinit. If a variable declared with constinit has dynamic initialization, the program is ill-formed. If no constinit declaration is reachable at the point of the initializing declaration, the program is ill-formed, no diagnostic required.\n", "decltype": "Inspects the declared type of an entity or the type and value category of an expression.\n", "auto": "For variables, specifies that the type of the variable that is being declared will be automatically deduced from its initializer.\n", "alignas": "Specifies the alignment requirement of a type or an object.\n", "typedef": "The typedef specifier, when used in a declaration's decl-specifier-seq, specifies that the declaration is a typedef declaration, and declares typedef-names rather than functions or objects. It may declare one or many identifiers on the same line (e.g. int and a pointer to int), it may declare array and function types, pointers and references, class types, etc. Every identifier introduced in this declaration becomes a typedef-name, which is a synonym for the type of the object or function that it would become if the keyword typedef were removed.\n", "type alias": "Type alias is a name that refers to a previously defined type (similar to typedef).\n", "elaborated type specifiers": "Elaborated type specifiers may be used to refer to a previously-declared class name (class, struct, or union) or to a previously-declared enum name even if the name was hidden by a non-type declaration. They may also be used to declare new class names. \n", "attributes": "Introduces implementation-defined attributes for types, objects, code, etc.\n", "static_assert": "Performs compile-time assertion checking\n", "initialization": "Initialization of a variable provides its initial value at the time of construction. \n", "default initialization": "This is the initialization performed when a variable is constructed with no initializer.\n", "value initialization": "This is the initialization performed when a variable is constructed with an empty initializer.\n", "copy initialization": "Initializes an object from another object\n", "direct initialization": "Initializes an object from explicit set of constructor arguments.\n", "aggregate initialization": "Initializes an aggregate from braced-init-list\n", "list initialization": "Initializes an object from braced-init-list\n", "reference initialization": "Binds a reference to an object\n", "static non-local initialization": "Initialization of a variable provides its initial value at the time of construction. \n", "zero": "Sets the initial value of an object to zero\n", "constant": "Sets the initial values of the static variables to a compile-time constant.\n", "dynamic non-local initialization": "Initialization of a variable provides its initial value at the time of construction. \n", "ordered": "Initialization of a variable provides its initial value at the time of construction. \n", "unordered": "Initialization of a variable provides its initial value at the time of construction. \n", "copy elision": "Omits copy and move (since C++11) constructors, resulting in zero-copy pass-by-value semantics.\n", "cout": "The 'c' in cout refers to 'character' and 'out' means 'output'. The cout object in C++ is an object of class ostream. After proper implementation of cout it is tied with cin, which is basically cout.flush() ", "functions": "Functions are C++ entities that associate a sequence of statements (a function body) with a name and a list of zero or more function parameters.\n", "function declaration": "A function declaration introduces the function name and its type. A function definition associates the function name/type with the function body. \n", "default arguments": "Allows a function to be called without providing one or more trailing arguments.\n", "variadic arguments": "Allows a function to accept any number of arguments.\n", "lambda expression": "Constructs a closure: an unnamed function object capable of capturing variables in scope.\n", "code": "Do you know? Almost anything powered by electricity requires code. And Ada Lovelace was the world\u00e2\u20ac\u2122s first computer programmer, who worte the first code all the way back in the mid-1800s", "argument-dependent lookup": "Argument-dependent lookup, also known as ADL, or Koenig lookup, is the set of rules for looking up the unqualified function names in function-call expressions, including implicit function calls to overloaded operators. These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces considered by the usual unqualified name lookup.\n", "overload resolution": "In order to compile a function call, the compiler must first perform name lookup, which, for functions, may involve argument-dependent lookup, and for function templates may be followed by template argument deduction. If these steps produce more than one candidate function, then overload resolution is performed to select the function that will actually be called.\n", "address of an overload set": "Besides function-call expressions, where overload resolution takes place, the name of an overloaded function may appear in the following 7 contexts:\n", "coroutines": "A coroutine is a function that can suspend execution to be resumed later. Coroutines are stackless: they suspend execution by returning to the caller and the data that is required to resume execution is stored separately from the stack. This allows for sequential code that executes asynchronously (e.g. to handle non-blocking I/O without explicit callbacks), and also supports algorithms on lazy-computed infinite sequences and other uses.\n", "statements": "Statements are fragments of the C++ program that are executed in sequence. The body of any function is a sequence of statements. For example:\n", "if": "Conditionally executes another statement.\n", "switch": "Transfers control to one of the several statements, depending on the value of a condition.\n", "for": "Executes init-statement once, then executes statement and iteration_expression repeatedly, until the value of condition becomes false. The test takes place before each iteration.\n", "range-for": "Executes a for loop over a range.\n", "while": "Executes a statement repeatedly, until the value of condition becomes false. The test takes place before each iteration.\n", "do-while": "Executes a statement repeatedly, until the value of expression becomes false. The test takes place after each iteration.\n", "continue": "Causes the remaining portion of the enclosing for, range-for, while or  do-while loop body to be skipped.\n", "break": "Causes the enclosing for, range-for, while or do-while loop or  switch statement to terminate.\n", "goto": "Transfers control unconditionally.\n", "return": "Terminates the current function and returns the specified value (if any) to its caller.\n", "synchronized and atomic": "Transactional memory is a concurrency synchronization mechanism that combines groups of statements in transactions, that are\n", "classes": "A class is a user-defined type.\n", "class types": "Classes and structs are user-defined types, defined by class-specifier, which appears in decl-specifier-seq of the declaration syntax. The class specifier has the following syntax:\n", "union types": "A union is a special class type that can hold only one of its non-static data members at a time.\n", "injected-class-name": "The injected-class-name is the name of a class within the scope of said class.\n", "data members": "Non-static data members are declared in a member specification of a class.\n", "member functions": "A non-static member function is a function that is declared in a member specification of a class without a static or friend specifier.\n", "static members": "Inside a class definition, the keyword static declares members that are not bound to class instances. \n", "nested classes": "A declaration of a class/struct or union may appear in within another class. Such declaration declares a nested class\n", "derived class": "Any class type (whether declared with class-key class or struct) may be declared as derived from one or more base classes which, in turn, may be derived from their own base classes, forming an inheritance hierarchy.\n", "using-declaration": "Introduces a name that is defined elsewhere into the declarative region where this using-declaration appears.\n", "empty base optimization": "Allows the size of an empty base subobject to be zero.\n", "virtual function": "The virtual specifier specifies that a non-static member function is virtual and supports dynamic dispatch. It may only appear in the decl-specifier-seq of the initial declaration of a non-static member function (i.e., when it is declared in the class definition).\n", "abstract class": "Defines an abstract type which cannot be instantiated, but can be used as a base class.\n", "override": "Specifies that a virtual function overrides another virtual function. \n", "final": "Specifies that a virtual function cannot be overridden in a derived class or that a class cannot be inherited from.\n", "member access": "In a member-specification of a class/struct or union, define the accessibility of subsequent members.\n", "friend": "The friend declaration appears in a class body and grants a function or another class access to private and protected members of the class where the friend declaration appears.\n", "bit fields": "Declares a class data member with explicit size, in bits. Adjacent bit field members may be packed to share and straddle the individual bytes.\n", "the this pointer": "The keyword this is a prvalue expression whose value is the address of the object, on which the member function is being called. It can appear in the following contexts:\n", "constructors and member initializer lists": "Constructor is a special non-static member function of a class that is used to initialize objects of its class type.\n", "default constructor": "A default constructor is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter). A type with a public default constructor is DefaultConstructible.\n", "destructor": "A destructor is a special member function that is called when the lifetime of an object ends. The purpose of the destructor is to free the resources that the object may have acquired during its lifetime.\n", "copy constructor": "A copy constructor of class T is a non-template constructor whose first parameter is T&\u200d, const T&\u200d, volatile T&\u200d, or const volatile T&\u200d, and either there are no other parameters, or the rest of the parameters all have default values.\n", "copy assignment": "A copy assignment operator of class T is a non-template non-static member function with the name operator= that takes exactly one parameter of type T, T&, const T&, volatile T&, or const volatile T&. For a type to be CopyAssignable, it must have a public copy assignment operator.\n", "move constructor": "A move constructor of class T is a non-template constructor whose first parameter is T&&, const T&&, volatile T&&, or const volatile T&&, and either there are no other parameters, or the rest of the parameters all have default values.\n", "move assignment": "A move assignment operator of class T is a non-template non-static member function with the name operator= that takes exactly one parameter of type T&&, const T&&, volatile T&&, or const volatile T&&.\n", "converting constructor": "A constructor that is not declared with the specifier explicit and which can be called with a single parameter (until C++11) is called a converting constructor.\n", "explicit specifier": "The explicit specifier may only appear within the decl-specifier-seq of the declaration of a constructor  or conversion function (since C++11) within its class definition.\n", "templates": "A template is a C++ entity that defines one of the following:\n", "template parameters and arguments": "Every template is parametrized by one or more template parameters, indicated in the parameter-list of the template declaration syntax:\n", "class template": "A class template defines a family of classes.\n", "function template": "A function template defines a family of functions.\n", "class member template": "Template declarations (class, function, and variables (since C++14)) can appear inside a member specification of any class, struct, or union that aren't local classes.\n", "variable template": "A variable template defines a family of variables or static data members.\n", "template argument deduction": "In order to instantiate a function template, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted, when an address of a function template is taken, and in some other contexts:\n", "explicit specialization": "Allows customizing the template code for a given set of template arguments.\n", "class template argument deduction": "In order to instantiate a class template, every template argument must be known, but not every template argument has to be specified. In the following contexts the compiler will deduce the missing template arguments from the type of the initializer:\n", "partial specialization": "Allows customizing class and variable (since C++14) templates for a given category of template arguments.\n", "parameter packs": "A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A function parameter pack is a function parameter that accepts zero or more function arguments.\n", "sizeof...": "Queries the number of elements in a parameter pack.\n", "fold-expressions": "Reduces (folds) a parameter pack over a binary operator.\n", "dependent names": "Inside the definition of a template (both class template and function template), the meaning of some constructs may differ from one instantiation to another. In particular, types and expressions may depend on types of type template parameters and values of non-type template parameters.\n", "sfinae": "\"Substitution Failure Is Not An Error\"\n", "constraints and concepts": "Class templates, function templates, and non-template functions (typically members of class templates) may be associated with a constraint, which specifies the requirements on template arguments, which can be used to select the most appropriate function overloads and template specializations.\n", "exceptions": "Exception handling provides a way of transferring control and information from some point in the execution of a program to a handler associated with a point previously passed by the execution (in other words, exception handling transfers control up the call stack)\n", "throw-expression": "Signals an erroneous condition and executes an error handler.\n", "try-catch block": "Associates one or more exception handlers (catch-clauses) with a compound statement.\n", "function-try-block": "Establishes an exception handler around the body of a function.\n", "noexcept specifier": "Specifies whether a function could throw exceptions.\n", "noexcept operator": "The noexcept operator performs a compile-time check that returns true if an expression is declared to not throw any exceptions.\n", "dynamic exception specification": "Lists the exceptions that a function might directly or indirectly throw.\n", "history of c++": "This book described the language as designed, including some features that were not yet implemented. It served as the de-facto standard until the ISO.\n", "extending the namespace std": "It is undefined behavior to add declarations or definitions to namespace std or to any namespace nested within std, with a few exceptions noted below\n", "resource acquisition is initialization": "Resource Acquisition Is Initialization or RAII, is a C++ programming technique[1][2] which binds the life cycle of a resource that must be acquired before use (allocated heap memory, thread of execution, open socket, open file, locked mutex, disk space, database connection\u2014anything that exists in limited supply) to the lifetime of an object.\n", "rule of three/five/zero": "If a class requires a user-defined destructor, a user-defined copy constructor, or a user-defined copy assignment operator, it almost certainly requires all three.\n", "pointer to implementation": "\"Pointer to implementation\" or \"pImpl\" is a C++ programming technique[1] that removes implementation details of a class from its object representation by placing them in a separate class, accessed through an opaque pointer:\n", "c++ for loop": "The C++ for loop is used to iterate a part of the program several times. If the number of iteration is fixed, it is recommended to use for loop than while or do-while loops."}